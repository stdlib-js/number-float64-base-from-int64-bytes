{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport IS_LITTLE_ENDIAN from '@stdlib/assert-is-little-endian';\nimport Uint8Array from '@stdlib/array-uint8';\nimport DataView from '@stdlib/array-dataview';\n\n\n// VARIABLES //\n\n// 2**32\nvar TWO_32 = 4294967296;\n\n// Initialize a workspace:\nvar WORKSPACE = new Uint8Array( 8 );\n\n\n// MAIN //\n\n/**\n* Converts a signed 64-bit integer byte array to a double-precision floating-point number.\n*\n* ## Notes\n*\n* -   The function assumes host byte order (endianness).\n*\n* @param {Uint8Array} bytes - byte array\n* @param {integer} stride - stride\n* @param {NonNegativeInteger} offset - index offset\n* @returns {number} double-precision floating-point number\n*\n* @example\n* import Uint8Array from '@stdlib/array-uint8';\n*\n* var bytes = new Uint8Array( [ 255, 255, 255, 255, 255, 255, 255, 255 ] );\n* var x = fromInt64Bytes( bytes, 1, 0 );\n* // returns -1.0\n*/\nfunction fromInt64Bytes( bytes, stride, offset ) {\n\tvar view;\n\tvar hi;\n\tvar lo;\n\tvar b;\n\tvar i;\n\n\tif ( stride === 1 ) { // contiguous\n\t\tb = bytes;\n\t} else { // non-contiguous\n\t\tb = WORKSPACE;\n\t\tfor ( i = 0; i < 8; i++ ) {\n\t\t\tb[ i ] = bytes[ offset ];\n\t\t\toffset += stride;\n\t\t}\n\t\toffset = 0;\n\t}\n\tview = new DataView( b.buffer, b.byteOffset, b.byteLength );\n\tif ( IS_LITTLE_ENDIAN ) {\n\t\tlo = view.getInt32( offset, IS_LITTLE_ENDIAN );\n\t\thi = view.getInt32( offset+4, IS_LITTLE_ENDIAN );\n\t} else {\n\t\thi = view.getInt32( offset, IS_LITTLE_ENDIAN );\n\t\tlo = view.getInt32( offset+4, IS_LITTLE_ENDIAN );\n\t}\n\tif ( lo < 0 ) {\n\t\tlo += TWO_32;\n\t}\n\treturn ( hi*TWO_32 ) + lo;\n}\n\n\n// EXPORTS //\n\nexport default fromInt64Bytes;\n"],"names":["WORKSPACE","Uint8Array","fromInt64Bytes","bytes","stride","offset","view","hi","lo","b","i","DataView","buffer","byteOffset","byteLength","IS_LITTLE_ENDIAN","getInt32"],"mappings":";;0QA8BA,IAGIA,EAAY,IAAIC,EAAY,GAwBhC,SAASC,EAAgBC,EAAOC,EAAQC,GACvC,IAAIC,EACAC,EACAC,EACAC,EACAC,EAEJ,GAAgB,IAAXN,EACJK,EAAIN,MACE,CAEN,IADAM,EAAIT,EACEU,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAGC,GAAMP,EAAOE,GAChBA,GAAUD,EAEXC,EAAS,CACT,CAYD,OAXAC,EAAO,IAAIK,EAAUF,EAAEG,OAAQH,EAAEI,WAAYJ,EAAEK,YAC1CC,GACJP,EAAKF,EAAKU,SAAUX,EAAQU,GAC5BR,EAAKD,EAAKU,SAAUX,EAAO,EAAGU,KAE9BR,EAAKD,EAAKU,SAAUX,EAAQU,GAC5BP,EAAKF,EAAKU,SAAUX,EAAO,EAAGU,IAE1BP,EAAK,IACTA,GArDW,uBAuDHD,EAAcC,CACxB"}